{
  "nomeCorso": "Sistemi operativi e reti",
  "docente": [
    {
      "first_name": "Pietro",
      "second_name": "Frasca"
    }
  ],
  "annoAccademico": "2011-2012",
  "crediti": "12",
  "settore": "INF/01",
  "anno": "2",
  "semestre": "1-2",
  "propedeuticit\u00e0": "Programmazione dei calcolatori con laboratorio. Reti logiche ed architettura dei calcolatori.",
  "comunicazioni": [],
  "lezioni": [
    {
      "id": "6",
      "data": "20-10-2011",
      "contenuto": "<p>Sincronizzazione tra processi. Cooperazione e competizione. Modello ad ambiente globale. Modello ad ambiente locale. Problema della mutua esclusione. Soluzioni al problema della mutua esclusione. Problema della comunicazione. Semafori. Soluzione al problema della mutua esclusione con semafori. Soluzione al problema della comunicazione con semafori: produttore-consumatore con buffer di capacit\u00e0 1.</p>"
    },
    {
      "id": "5",
      "data": "18-10-2011",
      "contenuto": "<p>SRTF. Round robin. Algoritmi di scheduling basati sulle priorit\u00e0. Algoritmi di scheduling a code multiple. Algoritmi di scheduling real-time. Algoritmo RT. Thread. Thread a livello utente e a livello kernel.</p>"
    },
    {
      "id": "4",
      "data": "13-10-2011",
      "contenuto": "<p>Interazione tra i processi. Esempio di processi cooperanti: modello produttore-consumatore. Esempio di processi in competizione. Trasferimento tra l'ambiente del kernel e l'ambiente dei processi. Scheduling. Scheduling a breve termine, a medio termine e lungo termine. Comportamento dei processi: cpu burst e i/o burst. Parametri di scheduling. Principali algoritmi di scheduling. FCFS. SJF.</p>"
    },
    {
      "id": "3",
      "data": "11-10-2011",
      "contenuto": "<p>Struttura a microkernel. Struttura client-server. Gestione dei processi. Definizione di processo. Stati di un processo. Transizioni di stato. Descrittore del processo. Code di processi. Cambio di contesto. Creazione e terminazione dei processi. Esempio di creazione di processo in unix.</p>"
    },
    {
      "id": "2",
      "data": "6-10-2011",
      "contenuto": "<p>Sistemi a partizione di tempo (time-sharing). Sistemi in tempo reale. Sistemi paralleli e distribuiti. Sistemi operativi per PC. Struttura dei sistemi operativi. Principali componenti del sistema operativo. Principali modelli strutturali. Sistemi stratificati.</p>"
    },
    {
      "id": "1",
      "data": "4-10-2011",
      "contenuto": "<p>Introduzione al corso. Principali funzioni di un Sistema operativo. Storia dei sistemi operativi. Sistemi batch. Sistemi batch multiprogrammati.</p>"
    }
  ],
  "materiale": [],
  "programma": "<table><tr><td>Il corso <i>\"Sistemi operativi e reti\"</i> \u00e8 l'unione di <i>\"Sistemi operativi con laboratorio\"</i> e di <i>\"Reti di calcolatori\" </i>dei precedenti anni accademici. Le lezioni, relative a <i>\"Sistemi operativi\"</i>, si svolgeranno nel I semestre, mentre le lezioni relative a <i>\"Reti di calcolatori\"</i> si svolgeranno nel II semestre. \r<br/> <br/><b>Propedeuticit\u00e0</b> <br/>Non si pu\u00f2 sostenere l'esame di Sistemi operativi e reti senza aver prima sostenuto gli esami di Programmazione dei calcolatori con laboratorio (PR) e Reti logiche ed architettura dei calcolatori (RLAC).\r<br/> <br/><b>Programma</b> <br/><b><i>Parte I: Sistemi operativi </i> (I semestre) </b> <br/><ul><li>Introduzione ai sistemi operativi. </li><li>Storia e classificazione dei sistemi operativi. </li><li>Richiami di architetture dei sistemi di elaborazione </li><li>Principali modelli strutturali. </li><li>Gestione dei processi.</li> <li>Threads. </li><li>Sincronizzazione dei processi.</li><li>Gestione della memoria. </li><li>Gestione dell' I/O.</li><li>Gestione del file system. </li><li>I sistemi operativi Unix e Linux. </li><li>Casi di studio: Unix e Linux </li></ul> <br/><b><i>Parte II: Reti di calcolatori </i> (II semestre) </b> <br/><ul><li>Reti di calcolatori e Internet. </li><li>Strato di applicazione.</li><li>Strato di trasporto. </li><li>Strato di rete e instradamento. </li><li>Strato di collegamento e reti di area locale. </li><li>Reti wireless</li></ul> <br/><b>Programma dettagliato relativo a Sistemi Operativi (Diario delle lezioni, I semestre)</b><table border=\"1\" cellpadding=\"4\" class=\"normal\"><tr><th>Lezione</th><th>Data</th><th>Argomento</th></tr><tr><td>1</td><td>4/10/2011</td><td>Introduzione al corso. Principali funzioni di un Sistema operativo. Storia dei sistemi operativi. Sistemi batch. Sistemi batch multiprogrammati.</td></tr><tr><td>2</td><td>6/10/2011</td><td>Sistemi a partizione di tempo (time-sharing). Sistemi in tempo reale. Sistemi paralleli e distribuiti. Sistemi operativi per PC.  Struttura dei sistemi operativi. Principali componenti del sistema operativo. Principali modelli strutturali. Sistemi stratificati. </td></tr><tr><td>3</td><td>11/10/2011</td><td> Struttura a microkernel. Struttura client-server. Gestione dei processi. Definizione di processo. Stati di un processo. Transizioni di stato. Descrittore del processo. Code di processi. Cambio di contesto. Creazione e terminazione dei processi. Esempio di creazione di processo in unix.</td></tr><tr><td>4</td><td>13/10/2011</td><td>  Interazione tra i processi. Esempio di processi cooperanti: modello produttore-consumatore. Esempio di processi in competizione. Trasferimento tra l'ambiente del kernel e l'ambiente dei processi. Scheduling. Scheduling a breve termine, a medio termine e lungo termine. Comportamento dei processi: cpu burst e i/o burst. Parametri di scheduling. Principali algoritmi di scheduling. FCFS. SJF. </td></tr><tr><td>5</td><td>18/11/2011</td><td> SRTF. Round robin. Algoritmi di scheduling basati sulle priorit\u00e0. Algoritmi di scheduling a code multiple. Algoritmi di scheduling real-time. Algoritmo RT. Thread. Thread a livello utente e a livello kernel.</td></tr><tr><td>6</td><td>20/10/2011</td><td> Sincronizzazione tra processi. Cooperazione e competizione. Modello ad ambiente globale. Modello ad ambiente locale. Problema della mutua esclusione. Soluzioni al problema della mutua esclusione. Problema della comunicazione. Semafori. Soluzione al problema della mutua esclusione con semafori. Soluzione al problema della comunicazione con semafori: produttore-consumatore con buffer di capacit\u00e0 1.</td></tr> <br/><tr><td>7</td><td>25/10/2011</td><td>Produttore-consumatore con buffer di capacit\u00e0 N. Send e receive. Soluzione al problema della comunicazione tra processi. Comunicazione diretta e indiretta. Sincronizzazione tra processi comunicanti.</td></tr><tr><td>8</td><td>27/10/2011</td><td>Blocco critico (stallo). Esempi di situazioni di stallo. Stallo con risorse consumabili. Condizioni per il blocco critico. Metodi per il trattamento del blocco cristico. Prevenzione statica e dinamica. Algoritmo del banchiere. Rilevamento dei blocchi critici. Gestione della memoria. La memoria virtuale di un processo. \r<br/></td></tr><tr><td>9</td><td>3/11/2011</td><td>Rilocazione statica e dinamica. MMU. Organizzazione della memoria virtuale. Allocazione della memoria fisica. Tecniche di gestione della memoria. Memoria partizionata. Partizioni fisse e variabili.</td></tr><tr><td>10</td><td>8/11/2011</td> <br/><td>Tecniche di allocazione mediante free-list. Partizioni multiple. Memoria segmentata.</td></tr><tr><td>11</td><td>10/11/2011</td><td>Memoria paginata. Segmentazione su richiesta. Paginazione su richiesta. Gestione del page-fault. Rimpiazzamento delle pagine. </td></tr><tr><td>12</td><td>15/11/2011</td><td>Algoritmi di rimpiazzamento delle pagine. Algoritmo second chance. Memoria segmentata e paginata. Gestione degli spazi virtuali. Paginazione a pi\u00f9 livelli. Gestione dell'I/O. Classificazione dei dispositivi. Struttura logica del sistema di I/O.</td></tr><tr><td>13</td><td>17/11/2011</td><td>Livello indipendente dai dispositivi. Bufferizzazione. Gestione degli errori e delle eccezioni. Tecnica di spooling. Livello dipendente dai dispositivi. Controller di un dispositivo. Gestione di un dispositivo mediante controllo di programma. Gestione di un dispositivo mediante interrupt. </td></tr><tr><td>14</td><td>22/11/2011</td><td>Descrittore di dispositivo. Driver di dispositivo. Gestione di un dispositivo con DMA. Flusso di controllo durante un trasferimento. Gestione del timer. Gestione dei dischi.</td></tr><tr><td>15</td><td>24/11/2011</td><td>Criteri di ordinamento dei dati su disco e politiche di scheduling. Esempio di memorizzazione su due tracce contigue e su tracce e settori sparsi. Algoritmi di scheduling FCFS, SSTF e SCAN. Dischi raid. Il file system. Struttura logica del file system. Gestione della stuttura logica del file system. Il livello di accesso. Strutture dati e operazioni di accesso ai file. Metodi di accesso: sequenziale, diretto e ad indice. </td></tr><tr><td>16</td><td>29/11/2011</td><td>  Il livello organizzazione fisica.  Tecniche di allocazione dei file. Allocazione contigua. Allocazione a lista concatenata, a lista con FAT, a indice. Protezione di file e directory. Matrice di protezione. ACL e C-list. Storia di Unix e Linux. Architettura di Unix. Interazione con l'utente. Shell. </td></tr><tr><td>17</td><td>1/12/2011</td><td>Processi e thread. Diagramma degli stati. Immagine di un processo Unix. System call per la gestione di processi. Creazione di processi. Terminazione di processi.</td></tr><tr><td>18</td><td>6/12/2010</td><td> Sostituzione del codice. Scheduling in Unix. Gestione della memoria.  Il file system. Struttura logica del file system.  La variabile PATH. </td></tr><tr><td>19</td><td>13/12/2011</td><td> Protezione. Autenticazione degli utenti. Il file /etc/passwd. Il file /etc/group. Controllo di accesso alle risorse.  ACL in Unix.  Organizzazione fisica del file system. Strutture dati del kernel per l'accesso ai file.  </td></tr><tr><td>20</td><td>15/12/2011</td><td>System call per i file. Interazione tra processi. Sincronizzazione: i segnali. System call per l'uso di segnali. Invio di segnali tra processi. </td></tr><tr><td>21</td><td>20/12/2011</td><td> Comunicazione: pipe. Chiamate di sistema per la sospensione di processi: pause, sleep e uspleep. I thread in Linux e Unix. I thread POSIX: la libreria pthread. Creazione e terminazione dei thread. Sincronizzazione tra thread. I mutex pthread.  Esempi.</td></tr><tr><td>22</td><td>22/12/2011</td><td>I semafori. Le variabili condition.  Esempi di sincronizzazione con le variabili condizione. Esempio di implementazione del modello produttore-consumatore.</td></tr><tr><td>23</td><td>10/01/2012</td><td>Intrduzione alla shell. Connessione ad un server con ssh. Gestione del file system. Operazioni sulle directory: posizionamento, creazione, cancellazione, listato e copia.  Operazione sui file: visualizzazione del contenuto, creazione, cancellazione, link. Esempi. Protezione. Monitoraggio e gestione dei processi. Controllo dell'esecuzione di processessi. Processi in foreground e background. <tr><td>24</td><td>12/01/2012</td><td>Filtri, ridirezione e piping. Esempio di applicazione multi thread: problema dei cinque filosofi a cena. Esempio di applicazione multi processo.\r<br/></td></tr></td></tr></table> <br/><b>Programma dettagliato relativo a Reti di calcolatori (Diario delle lezioni, II semestre)</b><table border=\"1\" cellpadding=\"4\" class=\"normal\"><tr><th>Lezione</th><th>Data</th><th>Argomento</th></tr><tr><td>1</td><td>6/03/2012</td><td>Internet. Descrizione dei servizi. Definizione di protocollo di rete. Applicazioni client/server. Servizi senza connessione e orientati alla connessione. La sezione interna della rete (nucleo). Commutazione di circuito e commutazione di pacchetto.</td></tr><tr><td>2</td><td>9/03/2012</td><td>Multiplazione (multiplexing) nelle reti a commutazione di circuito. Confronto tra commutazione di circuito e commutazione di pacchetto. Frammentazione del messaggio. Reti a commutazione di pacchetto datagram. Accesso alla rete. Accesso residenziale.</td></tr><tr><td>3</td><td>13/03/2011</td><td>Accesso aziendale. Accesso wireless. Mezzi trasmissivi. Doppini in rame. Cavi coassiali. Fibre ottiche. Canali radio terrestri. Canali radio satellitari. Gli ISP e le reti dorsali di Internet. Ritardi e perdite nelle reti a commutazione di pacchetto. Tipi di ritardo: trasmissione, propagazione, elaborazione, coda. Ritardo totale. Ritardo da host a host. Ritardi e percorsi in Internet. Traceroute(tracert).</td></tr><tr><td>4</td><td>16/03/2012</td><td>Perdita di pacchetti. Intensit\u00e0 del traffico.  Lo stack protocollare di Internet e il modello ISO OSI. Gli strati di Internet e i servizi che forniscono. </td></tr><tr><td>5</td><td>20/03/2012</td><td>Livello di applicazione. I principi delle applicazioni di rete. Lati client e server di un applicazione. Indirizzamento dei processi. Processi di comunicazione nella rete. Servizi formiti dai protocolli di trasporto alle applicazioni. Applicazioni di rete.  Web. Il protocollo HTTP. Formato del messaggio di richiesta HTTP.  </td><tr><td>6</td><td>23/03/2012</td><td>Formato del messaggio di risposta  HTTP. Get condizionato. Interazione utente-server: i cookie. Connessione non persistente e persistente. Connessione persistente senza parallelismo e con parallelismo. </td></tr><tr><td>7</td><td>27/03/2012</td><td>Il protocollo FTP. Posta Elettronica. SMTP. Formati dei messaggi di posta e MIME. Estensioni MIME per dati non ascii. Protocolli di accesso alla posta. POP3. IMAP. Posta elettronica con HTTP.</td></tr><tr><td>8</td><td>30/03/2012</td><td>DNS. Servizi forniti dal DNS. Funzionamento del DNS. Record DNS. Messaggi DNS.  </td></tr><tr><td>9</td><td>3/04/2012</td><td>Distribuzione di contenuti. Server proxy. Esempio d'uso dei proxy. Reti per la distribuzione dei contenuti (CDN). Condivisione di file P2P. Directory centralizzata. </td></tr><tr><td>10</td><td>10/04/2012</td><td>Directory decentralizzata. Query flooding. Confronto architetture C/S e P2P. Calcolo semplificato del tempo di distribuzione di un file per C/S e P2P. Programmazione delle Socket. </td></tr><tr><td>11</td><td>13/04/2012</td><td>Programmazione delle Socket con TCP. Esempio di applicazione Client/Server con TCP in Java. Programmazione delle socket con UDP. Esempio di applicazione Client/Server con UDP in Java.</td></tr></tr></table></td></tr><tr><td>12</td><td>20/04/2012</td><td>Lo strato di trasporto. Multiplexing e demultiplexing. UDP. Struttura del segmento UDP. Checksum di UDP. TCP. La connessione TCP. Struttura del segmento TCP. Numeri di sequenza e numeri di riscontro. </td></tr><tr><td>13</td><td>24/04/2012</td><td>Esempi numeri di sequenza e di riscontro Stima del tempo di andata e ritorno e di timeout. Intervallo di timeout per le ritrasmissioni. Trasferimento affidabile dei dati. Raddoppio del timeout. Ritrasmissione rapida. </td></tr><tr><td>14</td><td>27/04/2012</td><td>Instaurazione della connessione TCP. Controllo del flusso. Controllo della congestione TCP. AIMD. Partenza lenta. Reazione a eventi di timeout. Prevenzione della congestione. Descrizione macroscopica del throughput TCP.</td></tr><tr><td>15</td><td>4/05/2012</td><td> Strato di rete. Reti a circuito virtuale e a datagram. Il protocollo IP. Formato dei datagram IPv4. Frammentazione IP. Indirizzamento IPv4.</td></tr><tr><td>16</td><td>8/05/2012</td><td> Indirizzamento per classe. Indirizzamento CIDR. Assegnazione di indirizzi IP. Configurazione delle interfacce di rete di host e router. DHCP. Traduzione degli indirizzi di rete (NAT). UPnP. </td></tr><td>17</td><td>11/05/2012</td><td>ICMP. IPv6. Formato del datagram IPv6. Passaggio da IPv4 a IPv6. Metodo dual-stack. Metodo del tunneling. Algoritmi di instradamento. Algoritmi di instradamento LS.</td></table>",
  "testiRiferimento": "<table><tr><td><b>Testi di riferimento</b> <br/>Sistemi operativi, II ed. - P. Ancilotti, M. Boari, A. Ciampolini, G. Lipari - McGraw-Hill \r<br/>Reti di Calcolatori e Internet, IV ed. - Un approccio top-down - J.F. Kurose, K.W. Ross - Pearson - Addison Wesley. \r<br/> <br/><b>Libri consigliati per approfondimenti</b> <br/>Sistemi Operativi, VII ed., A. Silberschatz, P. Galvin, G. Gagne. Pearson. \r<br/>I moderni Sistemi Operativi, III ed., A. S. Tanenbaum. Pearson - Prentice Hall.\r<br/>Sistemi operativi, D. M. Dhamdhere, McGraw-Hill.\r<br/>Reti di Calcolatori e Internet, B. A. Forouzan, McGraw-Hill.</td></tr></table>",
  "ricevimento": "<table><tr><td>Stanza docente (0103) - Marted\u00ec ore 16.00 - 17.00.\r<br/>Per appuntamento via email. \r<br/></td></tr></table>",
  "modalit\u00e0Esame": "<table><tr><td><p>Gli studenti iscritti al nuovo ordinamento devono sostenere l'esame \"Sistemi operativi e reti\" di 12 crediti. Gli studenti iscritti al vecchio ordinamento devono sostenere separatamente gli esami \"Sistemi operativi\" di 6 crediti e \"Reti di calcolatori\" di 6 crediti. <br>L'esame consiste in una prova scritta e in una prova orale. Il testo della prova scritta \u00e8 suddiviso in due parti. La prima parte \u00e8 composta da un gruppo di 4-5 domande che riguardano argomenti di \"Sistemi operativi\". La seconda parte, \u00e8 composta da un gruppo di 4-5 domande, relative ad argomenti di \"Reti di calcolatori\". Le domande sono del tipo a risposta aperta o sottoforma di problemi. Per la parte Sistemi operativi una delle domande consiste nello sviluppo di un breve programma in linguaggio C basato sulle system call POSIX studiate durante il corso. <br>La durata dell'esame di 12 crediti \u00e8 di 3 ore, mentre la durata dell'esame di 6 crediti \u00e8 di 1 ora e 30 minuti. Durante lo svolgimento della prova scritta \u00e8 vietato l'uso di libri e/o appunti di qualsiasi genere. <br>Per sostenere la prova orale \u00e8 necessario aver superato la prova scritta con una votazione di almeno 18/30. Inoltre, lo studente pu\u00f2 svolgere una tesina facoltativa consistente nella realizzazione di un'applicazione in java basata sulla programmazione dei socket o di un'applicazione multi-thread scritta in c .<br>La tesina deve essere consegnata (personalmente o via e-mail) almeno una settimana prima della data della prova orale. La realizzazione della tesina consente di migliorare la votazione di 1,2 o 3 punti. <br>Per sostenere l'esame \u00e8 obbligatorio prenotarsi mediante il servizio \"Servizi on Line\" all'indirizzo http://delphi.uniroma2.it<br>Una raccolta di testi di esame relativi agli a.a. passati e vari esempi di programmi sulle system call POSIX e sulla programmazione dei socket sono disponibili nell'area \"materiale didattico\".</br></br></br></br></br></br></p>\n<p>\u00a0</p>\n<p><em>Esame parziale (esonero) A.A. 2011/2012 </em><br>Gli studenti del nuovo ordinamento possono sostenere, nel solo appello invernale, l'esame parziale (esonero) di \"Sistemi operativi e reti\" che consiste in una prova scritta e in una prova orale basate sugli argomenti della prima parte del corso (Sistemi operativi).</br></p>\n<p>Lo studente che intende sostenere l'esame parziale deve prenotarsi inviando una e-mail all'indirizzo del docente: frasca@mat.uniroma2.it, indicando come oggetto la frase \"esame parziale SOR A.A. 2011/2012\" e indicando nel messaggio il proprio cognome, nome e numero di matricola. L'e-mail di prenotazione deve arrivare entro il 18/02/2012. <br>Lo studente che supera l'esame parziale deve sostenere la restante parte di SOR entro l'anno accademico 2011/2012. <br>Il testo della prova scritta \u00e8 composto da un gruppo di 4-5 domande. Le domande sono del tipo a risposta aperta o sottoforma di problemi. Una delle domande consiste nello sviluppo di un breve programma in linguaggio C basato sulle system call POSIX studiate durante il corso. La durata della prova scritta dell'esame parziale \u00e8 di 1 ora e 30 minuti. Durante lo svolgimento della prova scritta \u00e8 vietato l'uso di libri e/o appunti di qualsiasi genere. <br>Per sostenere la prova orale \u00e8 necessario aver superato la prova scritta con una votazione di almeno 18/30.</br></br></br></p></td></tr></table>"
}