{
  "nomeCorso": "Algoritmi e strutture dati 1",
  "docente": [
    {
      "first_name": "Andrea",
      "second_name": "Clementi"
    }
  ],
  "annoAccademico": "2002-2003",
  "crediti": "6",
  "settore": "",
  "anno": "1",
  "semestre": "2",
  "propedeuticit\u00e0": "Nessuna",
  "comunicazioni": [],
  "lezioni": [],
  "materiale": [],
  "programma": "<table><tr><td>Il presente documento contiene una dettagliata descrizione degli argomenti del corso ASD1. Gli argomenti sono divisi in lezioni . Esse devono essere intese come una suddivisione logica del corso e non temporale. Il tempo impiegato per ogni lezione varier\u00e0 in funzione del particolare argomento trattato e del tempo di assimilazione di questo da parte degli studenti. \r\n  \r\nIntroduzione: Lezione I \r\n- Il concetto di problema computazionale. Esempi: a) ricerca del massimo in un insieme di n interi positivi; b) test di primalit\u00e0 di un numero intero positivo. Prima formalizzazione dei vari tipi di problemi: problemi di ricerca, problemi decisionali, problemi di ottimizzazione. \r\n- Metodi di risoluzione per i problemi computazionali (ALGORITMI): algoritmi per gli esempi a) e b). Formalizzazione di un algoritmo attraverso uno pseudo-linguaggio di programmazione. \r\n- Concetto di correttezza di un algoritmo. \r\n- [Be00]: Cap. 1 (Introduzione); [Se93]: Cap. 6. \r\n  \r\nIntroduzione: Lezione II \r\n- Parametri per la valutazione degli algoritmi. Efficienza di un algoritmo. Esempi. \r\n- Definizione di un modello di calcolo astratto. \r\n- Misure di complessit\u00e0: tempo e spazio (caso peggiore). \r\n- Rappresentazione e dimensione dell'Input. \r\n- Complessit\u00e0 intrinseca di un problema computazionale: i lower bounds. \r\n- Applicazione dei suddetti concetti ad alcuni algoritmi. \r\n- [Be00]: Cap. 1 (Introduzione); [Se93]: Cap. 6. \r\nIntroduzione: Lezione III \r\n- Operazioni dominanti. \r\n- Caso peggiore, caso migliore e caso medio della complessit\u00e0 di un algoritmo. \r\n- Analisi asintotica. Le notazioni asintotiche. \r\n- Esempi. \r\n- [Be00]: Cap. 1 (Introduzione); [Se93]: Cap. 6. \r\n  \r\nStrutture Dati Astratte fondamentali: Lezione I \r\n- Strutture dati lineari: liste, pile, code, vettori. \r\n- Complessit\u00e0 di alcune operazioni fondamentali su strutture lineari. \r\n- [Be00]: Cap. 1, 2 e 3. \r\nStrutture Dati Astratte fondamentali: Lezione II \r\n- Strutture dati non lineari: gli alberi. \r\n- Rappresentazione di alberi mediante liste. \r\n- Vari tipi di alberi; propriet\u00e0 degli alberi. \r\n- Visita in pre/ord/post-ordine e per livelli di un albero. \r\n- Complessit\u00e0 temporale delle visite. \r\n- Rappresentazione di Insiemi di elementi mediante Strutture Dati. \r\n- [Be00]: Cap. 4. \r\n  \r\n  \r\nIl metodo DIVIDE ET IMPERA e la Ricorsione \r\n- Il paradigma generale DIVIDE ET IMPERA: problemi e sottoproblemi. \r\n- La relazione di ricorrenza. \r\n- Valutazione dell'efficienza. \r\n- Un esempio significativo: la moltiplicazione di interi. \r\n- [Be00]: Cap. 11; [Se93]: Cap. 5. \r\n  \r\nGestione di insiemi di dati: Lezione I \r\n- Introduzione dei problemi: ricerca di un elemento, inserimento, cancellazione, ordinamento e code di priorit\u00e0. \r\n- Tabelle ad accesso diretto: le funzioni Hash.   \r\n- Metodi di scansione: lineare e doppio. \r\n- [Be00]: Cap. 6; [Se93]: Cap. 16. \r\nGestione di insiemi di dati: Lezione II \r\n- Alberi binari di ricerca. Profondit\u00e0 e concetto di bilanciamento di un albero di ricerca. \r\n- Analisi della complessit\u00e0 delle operazioni fondamentali su alberi di ricerca. Alberi bilanciati. \r\n- [Be00]: Cap. 8; [Se93]: Cap. 14 e15.\r\n\r\n\r\nGestione di insiemi di dati: Lezione III \r\n- Il problema dell'ordinamento di n elementi confrontabili. \r\n- I paradigmi degli algoritmi elementari. \r\n- Il Selection Sort: l'algoritmo. \r\n- L'Insertion Sort: l'algoritmo. \r\n- Analisi del caso peggiore e del caso migliore dei suddetti algoritmi. \r\n- [Se93]: Cap. 8. \r\n  \r\nGestione di insiemi di dati: Lezione IV \r\n- Il problema dell'ordinamento di n elementi confrontabili: gli algoritmi ottimali. \r\n- Un lower bound non banale per l'ordinamento. \r\n- L'algoritmo Merge Sort e dimostrazione della sua ottimalit\u00e0. \r\n- La struttura Heap per la gestione delle code di priorit\u00e0 (ricerca ed estrazione efficiente del massimo). \r\n- L'Heap Sort e la sua ottimalit\u00e0. \r\n- [Be00]: Cap. 11, [Be00]: Cap. 7; [Se93]: Cap. 9, 10, 11 e12. \r\n  \r\nAlgoritmi fondamentali su grafi: Lezione I \r\n- Definizioni e concetti di base della teoria dei grafi. \r\n- Classi di grafi particolari. \r\n- Le dimensioni di un grafo. \r\n- Rappresentazioni e relative implementazioni di un grafo e di un grafo pesato. \r\n- [Be00]: Cap. 9; [Se93]: Cap. 29. \r\n  \r\nAlgoritmi fondamentali su grafi: Lezione II \r\n- Algoritmi di visita di un grafo: il paradigma generale. \r\n- Algoritmo di visita in ampiezza. \r\n- Algoritmo di visita in profondit\u00e0. \r\n- Propriet\u00e0 dei grafi verificabili mediante le suddette visite. \r\n- [Be00]: Cap. 9; [Se93]: Cap. 29. \r\n  \r\nAlgoritmi fondamentali su grafi: Lezione III \r\n- Il problema dei cammini minimi di un grafo pesato. \r\n- L'algoritmo di Dijkstra. \r\n- [Be00]: Cap.14; [Se93]: Cap. 29. \r\n  \r\nAlgoritmi fondamentali su grafi: Lezione IV \r\n- Il problema del Minimum Spanning Tree in un grafo pesato. \r\n- L'algoritmo di Prim. \r\n- [Be00]: Cap. 13; [Se93]: Cap. 31. \r\n</td></tr></table>",
  "testiRiferimento": "<table><tr><td></td></tr></table>",
  "ricevimento": "<table><tr><td></td></tr></table>",
  "modalit\u00e0Esame": "<table><tr><td>null</td></tr></table>"
}